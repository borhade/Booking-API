1)go mod init folder-name(go mod init Booking-API)
2)create one file and give name main.go
3)give package name i.e package main

Youtube channel:
https://www.youtube.com/@Go-Guruji/videos

-------------------------------------------------------------
1)Panic , recover and defer

func main() {
	fmt.Println("hi my name is vishal")
	SlicePanic()
	fmt.Println("hi my name is borhade")
}

func SlicePanic() {
	defer HandlePanic()
	res := []int{1, 2, 3}
	fmt.Println("len", res[3])
	//defer HandlePanic()
	//panic("divison by zero")
}

func HandlePanic() {
	r := recover()
	if r != nil {
		fmt.Println("Handle Panic", r)
	}
}

--------------------------Error Handle go-----------

package main

import (
	"fmt"
)

/*type Rectangle struct {
	height int
		width  int
}

type MathOperation interface {
	Add(a, b int) int
	Area(a, b int) int
}

func (r Rectangle) Add(a, b int) int {
	res := r.height + r.width + a + b
	return res
}
func (r Rectangle) Area(a, b int) int {
	res := r.height * r.width * a * b
	return res
}*/

type CustomError struct {
	errorMessage string
}

func (err *CustomError) Error() string {
	return err.errorMessage
}

func main() {
	a := 2
	b := 3
	res, err := SumOfDigit(a, b)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("my name is vishal", res)
}

func SumOfDigit(a, b int) (int, error) {

	if b > a {
		return 0, &CustomError{errorMessage: "test"}
	}
	sum := a + b
	return sum, nil
	//defer HandlePanic()
	//panic("divison by zero")
}

func HandlePanic() {
	r := recover()
	if r != nil {
		fmt.Println("Handle Panic", r)
	}
}

-------------------------------------Why we need point -----------------

pointer basically better for memory allocation
mean create one varible and their value and access from anywhere using different variable

i.e

x :=6

p:=&x
b:=&x
------------------------------student struct --------------
type Student struct {
	Id    int    `json:"Id"`
	Name  string `json:"Name"`
	Posts []StudentPost
}

type StudentPost struct {
	PostId   int    `json:"PostId"`
	PostName string `json:"PostName"`
	Comments string `json:"Comments"`
}

func main() {

	var data []StudentPost
	data = append(data, StudentPost{PostId: 234, PostName: "vishal borhade", Comments: "This is vishal and i am learning go lang"})
	data = append(data, StudentPost{PostId: 124, PostName: "shivani thankar", Comments: "vishal.."})

	for _, value := range data {
		fmt.Println(value.PostId)
	}

	//fmt.Println(data)
	//b := 300
	//fmt.Println("address of a ", &a)
	//fmt.Println("address of a ", &b)
	//SumOfDigit(&a)
	//fmt.Println("after function address of a ", a)
	//fmt.Println("address of a ", b)
}

----------------------------------------------json unmarshal --------------

n Go, you can unmarshal (decode) data from a serialized format, such as JSON, XML, or other data formats, into a Go data structure. The encoding/json package is commonly used for unmarshaling JSON data. 
Here's how to unmarshal data from a JSON string into a Go struct:

-------------------------------------------map struct-------------
data := make([]map[int]string, 0)
	for i := 0; i < 5; i++ {
		test := map[int]string{
			i: fmt.Sprintf("Alice is:%d", i),
		}
		data = append(data, test)
	}
------------------------------select statment with channel data--------------

In Go, the select statement is used to wait on multiple channel operations and 
perform different actions depending on which channel is ready to proceed.
 It's a powerful tool for managing concurrent operations. Here's a simple example of how to use select:

 example:


func main() {
	ch1 := make(chan int)
	ch2 := make(chan string)
	go second(ch2)
	go first(ch1)

	fmt.Println("hi this gorutine in goalng")
	select {
	case val1 := <-ch1:
		fmt.Println("Yes I am execute", val1)
	case val2 := <-ch2:
		fmt.Println("I am second", val2)
		//default:
		//fmt.Println("Yes I am default case")
	}

	//b := 300
	//fmt.Println("address of a ", &a)
	//fmt.Println("address of a ", &b)
	//SumOfDigit(&a)
	//fmt.Println("after function address of a ", a)
	//fmt.Println("address of a ", b)
}

func first(ch1 chan int) {
	time.Sleep(4 * time.Second)
	ch1 <- 23
	//fmt.Println("My name is vishal")\
	//fmt.Println("address of a...", *a)
}

func second(ch2 chan string) {
	time.Sleep(2 * time.Second)
	ch2 <- "Hello, Go!"
}
 In this example, we have two goroutines sending data on two different channels, 
 ch1 and ch2. The select statement waits for data to be received on either channel and then executes the corresponding case. Here's what happens:

The first goroutine sends the integer value 42 on ch1 after a 2-second delay.
The second goroutine sends the string "Hello, Go!" on ch2 after a 1-second delay.
The select statement waits for data from either channel. Whichever channel 
provides data first will have its associated case executed. In this case, ch2 is
 the first to provide data, so the message "Received from ch2: Hello, Go!" is printed.


